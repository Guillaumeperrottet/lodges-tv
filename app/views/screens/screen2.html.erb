<!-- Slide 1 -->
<div class="slider">
  <div class="slide active">
    <div class="google-slides-container">
      <div class="slides-loader">
        <div class="loader">
          <div class="loader-inner"></div>
        </div>
      </div>
      <!-- Premier iframe pour le premier cycle -->
      <iframe
        id="google-slides-1"
        class="active-frame"
        src="https://docs.google.com/presentation/d/e/2PACX-1vSvfKn36DdHtN34zAKaEmG6-yrkPRF2Pks08fXsoTy5M-SqQlYZ2njpUVGuqr5_S1ZrcEg4ZHOS9s5v/embed?start=true&loop=true&delayms=15000&rm=minimal"
        frameborder="0"
        allowfullscreen="true"
        mozallowfullscreen="true"
        webkitallowfullscreen="true"
        onload="this.parentElement.classList.remove('loading')">
      </iframe>
      <!-- Deuxième iframe pour le cycle suivant -->
      <iframe
        id="google-slides-2"
        class="inactive-frame"
        src="about:blank"
        frameborder="0"
        allowfullscreen="true"
        mozallowfullscreen="true"
        webkitallowfullscreen="true"
        onload="this.parentElement.classList.remove('loading')">
      </iframe>

      <!-- Ajoutez cet iframe caché dans votre HTML -->
      <iframe
        id="google-slides-preload"
        class="hidden-frame"
        src="about:blank"
        frameborder="0"
        allowfullscreen="true"
        mozallowfullscreen="true"
        webkitallowfullscreen="true">
      </iframe>
    </div>
  </div>

  <!-- Slide 2 - Météo -->
  <div class="slide">
    <div class="background-image" style="background-image: url('https://res.cloudinary.com/dafkgjhwt/image/upload/v1741704836/chuttersnap-olqdyg9Bxg4-unsplash_qepzjz.jpg');"></div>
    <div class="header transparent">
      <h1>POINT MÉTÉO</h1>
      <h2>Quel temps fait-il ?</h2>
    </div>
    <div class="content weather">
      <div id="weather-container">
        <div class="loader">
          <div class="loader-inner"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Slide 3 - Conditions Nautiques -->
  <div class="slide">
  <div class="background-image" style="background-image: url('https://res.cloudinary.com/dafkgjhwt/image/upload/v1741707717/mer_euf77x.jpg');"></div>
    <div class="header transparent">
      <h1>POINT NAUTIQUE</h1>
      <h2>Quelles sont les conditions ?</h2>
    </div>
    <div class="content weather-conditions">
      <div id="marine-container">
        <div class="marine-data-grid">
          <!-- Wind Speed Panel -->
          <div class="marine-panel wind-panel">
            <h2>Vent</h2>
            <div class="wind-icon">
              <i class="wind-arrow"></i>
            </div>
            <p class="wind-speed">-- kts</p>
            <p class="wind-direction">Direction: --</p>
          </div>

          <!-- Water Temperature Panel -->
          <div class="marine-panel water-panel">
            <h2>Température Eau mer</h2>
            <div class="temp-icon">
              <i class="water-icon"></i>
            </div>
            <p class="water-temp">-- °C</p>
            <p class="water-conditions">--</p>
          </div>

          <!-- Wind Forecast Chart -->
          <div class="marine-panel chart-panel">
            <h2>Prévision Vent 24h</h2>
            <canvas id="windChart"></canvas>
          </div>

          <!-- Tide Information -->
          <div class="marine-panel tide-panel">
            <h2>Marées</h2>
            <div class="tide-info">
              <div class="tide-high">
                <p>Marée Haute</p>
                <p class="tide-time">--:--</p>
                <p class="tide-height">-- m</p>
              </div>
              <div class="tide-low">
                <p>Marée Basse</p>
                <p class="tide-time">--:--</p>
                <p class="tide-height">-- m</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
    const slides = document.querySelectorAll('.slider .slide');
    let currentSlideIndex = 0;
    const regularSlideDuration = 15000;
    const googleSlidesDuration = 75000; // 5 slides * 15 secondes
    let slideInterval;
    let currentFrame = 1;
    const googleSlidesUrl = "https://docs.google.com/presentation/d/e/2PACX-1vSvfKn36DdHtN34zAKaEmG6-yrkPRF2Pks08fXsoTy5M-SqQlYZ2njpUVGuqr5_S1ZrcEg4ZHOS9s5v/embed?start=true&loop=false&delayms=10000&rm=minimal";

    // Uniquement précharger le Google Slides
    const preloadFrame = document.getElementById('google-slides-preload');
    if (preloadFrame) {
      preloadFrame.src = googleSlidesUrl;
    }


    function switchGoogleSlides() {
        const activeFrame = document.getElementById(`google-slides-${currentFrame}`);
        const nextFrame = document.getElementById(`google-slides-${currentFrame === 1 ? 2 : 1}`);
        const container = activeFrame.parentElement;

        // Transition entre les frames
        container.classList.add('loading');

        if (nextFrame.src === 'about:blank') {
          nextFrame.src = googleSlidesUrl;
        }

        // Gestion de l'événement onload pour terminer la transition
        nextFrame.onload = function() {
          activeFrame.classList.remove('active-frame');
          activeFrame.classList.add('inactive-frame');
          nextFrame.classList.remove('inactive-frame');
          nextFrame.classList.add('active-frame');
          container.classList.remove('loading');
          currentFrame = currentFrame === 1 ? 2 : 1;

          // Précharger la prochaine itération une fois la transition terminée
          setTimeout(() => {
            activeFrame.src = 'about:blank';
            if (preloadFrame) {
              preloadFrame.src = googleSlidesUrl;
            }
          }, 1000);
        };

        // Gestion des erreurs
        nextFrame.onerror = function() {
          console.error("Erreur lors du chargement de l'iframe Google Slides");
          container.classList.remove('loading');
          // Continuer quand même avec la transition
          activeFrame.classList.remove('active-frame');
          activeFrame.classList.add('inactive-frame');
          nextFrame.classList.remove('inactive-frame');
          nextFrame.classList.add('active-frame');
          currentFrame = currentFrame === 1 ? 2 : 1;
        };
      }

    function showNextSlide() {
      const nextSlideIndex = (currentSlideIndex + 1) % slides.length;

      // Si on revient au début (Google Slides)
      if (nextSlideIndex === 0) {
        // Transition vers les Google Slides
        clearInterval(slideInterval);
        slides[currentSlideIndex].classList.remove('active');
        currentSlideIndex = nextSlideIndex;
        slides[currentSlideIndex].classList.add('active');
        switchGoogleSlides();

        // Programmer le passage à la diapositive suivante après la durée des Google Slides
        setTimeout(startRegularCycle, googleSlidesDuration);
      } else {
        // Pour les autres diapositives, transition simple
        slides[currentSlideIndex].classList.remove('active');
        currentSlideIndex = nextSlideIndex;
        slides[currentSlideIndex].classList.add('active');

        // À la dernière diapositive, précharger Google Slides pour le prochain cycle
        if (currentSlideIndex === slides.length - 1 && preloadFrame) {
          preloadFrame.src = googleSlidesUrl;
        }
      }
    }


    function startRegularCycle() {
      showNextSlide(); // Passer à la météo
      slideInterval = setInterval(showNextSlide, regularSlideDuration);
    }


    // Démarrer le premier cycle après un court délai pour permettre au premier iframe de se charger
    setTimeout(() => {
      setTimeout(startRegularCycle, googleSlidesDuration);
    }, 500);

    // --- COMMON VARIABLES ---
    const apiKey = "9556a80b8f760d847e244de8b062a80f";
    const lat = 43.5;
    const lon = 4.9;
    const apiUrl = `https://api.openweathermap.org/data/3.0/onecall?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=fr`;

    // --- METEO (One Call API 3.0) ---
    const weatherContainer = document.getElementById("weather-container");

    // Vérifier que weatherContainer existe avant de continuer
    if (weatherContainer) {
      // Ajouter la classe loading au début
      weatherContainer.classList.add('loading');

      fetch(apiUrl)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          console.log("Données météo reçues :", data);
          if (!data.daily || data.daily.length < 4) {
            throw new Error("Données météo incomplètes");
          }

          // Générer le HTML pour l'affichage des 4 jours (aujourd'hui + 3 jours)
          let forecastHtml = `
            <div class="forecast-container">
          `;

          data.daily.slice(0, 4).forEach((day, index) => {
            const date = new Date(day.dt * 1000);
            const dayName = date.toLocaleDateString("fr-FR", { weekday: "long" });
            const temperature = Math.round(day.temp.day);
            const description = day.weather[0].description;
            const iconCode = day.weather[0].icon;
            // Utiliser l'image de meilleure qualité (4x au lieu de 2x)
            const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@4x.png`;
            const dayLabel = index === 0 ? "Aujourd'hui" : dayName.charAt(0).toUpperCase() + dayName.slice(1);

            forecastHtml += `
              <div class="daily-forecast">
                <h2>${dayLabel}</h2>
                <div class="weather-icon">
                  <img src="${iconUrl}" alt="${description}">
                </div>
                <p class="temperature">${temperature} °C</p>
                <p class="description">${description}</p>
              </div>
            `;
          });

          forecastHtml += `</div>`;

          // Retirer la classe loading et injecter le contenu
          weatherContainer.classList.remove('loading');
          weatherContainer.innerHTML = forecastHtml;
        })
        .catch(error => {
          console.error("Erreur lors de la récupération de la météo :", error);
          weatherContainer.classList.remove('loading');
          weatherContainer.innerHTML = "<p class='error-message'>Impossible de récupérer la météo pour le moment.</p>";
        });
    }

    // --- MARINE CONDITIONS ---
    const marineContainer = document.getElementById("marine-container");
    const windSpeedElement = document.querySelector(".wind-speed");
    const windDirectionElement = document.querySelector(".wind-direction");
    const waterTempElement = document.querySelector(".water-temp");
    const waterConditionsElement = document.querySelector(".water-conditions");

    // Vérifier que les éléments existent avant de les utiliser
    if (windSpeedElement && windDirectionElement && marineContainer) {
      console.log("windSpeedElement:", windSpeedElement);
      console.log("windDirectionElement:", windDirectionElement);

      // Using the same API call as weather, to avoid duplication
      fetch(apiUrl)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          // Wind data from current conditions
          if (data.current) {
            const windSpeed = Math.round(data.current.wind_speed * 1.94); // Convert m/s to knots
            const windDeg = data.current.wind_deg;

            // Update wind elements
            windSpeedElement.textContent = `${windSpeed} kts`;

            // Convert degrees to cardinal direction
            const directions = ["Nord", "Nord-Est", "Est", "Sud-Est", "Sud", "Sud-Ouest", "Ouest", "Nord-Ouest"];
            const index = Math.round(((windDeg + 22.5) % 360) / 45);
            windDirectionElement.textContent = `Direction: ${directions[index % 8]}`;

            // Rotate wind arrow according to direction
            const windArrow = document.querySelector(".wind-arrow");
            if (windArrow) {
              windArrow.style.transform = `rotate(${windDeg}deg)`;
            }
          }

          // Get hourly forecast for chart
          if (data.hourly && data.hourly.length >= 24) {
            const windChart = document.getElementById('windChart');
            if (windChart) {
              const hourlyData = data.hourly.slice(0, 24);
              const times = hourlyData.map(hour => {
                const date = new Date(hour.dt * 1000);
                return date.getHours() + 'h';
              });

              const windSpeeds = hourlyData.map(hour => Math.round(hour.wind_speed * 1.94 * 10) / 10); // Précision à 0.1 près

              const ctx = windChart.getContext('2d');
              const windChartObj = new Chart(ctx, {
                type: 'line',
                data: {
                  labels: times,
                  datasets: [{
                    label: 'Vitesse du vent (kts)',
                    data: windSpeeds,
                    fill: false,
                    backgroundColor: '#C6965B',
                    borderColor: '#C6965B',
                    tension: 0.4,
                    pointRadius: 3,
                    pointBackgroundColor: '#C6965B'
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  layout: {
                    padding: {
                      left: 10,
                      right: 10,
                      top: 10,
                      bottom: 10
                    }
                  },
                  scales: {
                    y: {
                      beginAtZero: false, // Ne commence pas à zéro pour plus de précision
                      grid: {
                        color: 'rgba(0, 0, 0, 0.1)',
                      },
                      ticks: {
                        stepSize: 2, // Incréments de 2 kts
                        font: {
                          size: 14
                        },
                        callback: function(value) {
                          return value + ' kts';
                        }
                      },
                      afterDataLimits: (scale) => {
                        // Ajuste les limites pour avoir une marge de 2 kts au-dessus et en-dessous
                        const minValue = Math.floor(Math.min(...windSpeeds) - 2);
                        const maxValue = Math.ceil(Math.max(...windSpeeds) + 2);
                        scale.min = Math.max(0, minValue); // Ne descend pas en dessous de 0
                        scale.max = maxValue;
                      }
                    },
                    x: {
                      grid: {
                        display: false
                      },
                      ticks: {
                        font: {
                          size: 14
                        },
                        maxRotation: 0,
                        maxTicksLimit: 8 // Limite le nombre d'heures affichées pour plus de clarté
                      }
                    }
                  },
                  plugins: {
                    legend: {
                      display: false
                    },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          return context.parsed.y.toFixed(1) + ' kts'; // Affiche une décimale dans le tooltip
                        }
                      }
                    }
                  }
                }
              });
            }
          }
        })
        .catch(error => {
          console.error("Erreur lors de la récupération des données marines :", error);
          marineContainer.innerHTML = "<p class='error-message'>Impossible de récupérer les données marines pour le moment.</p>";
        });
    }

    // --- STORMGLASS API WITH CACHING ---
    const stormglassApiKey = "d2c7d6b0-f9ca-11ef-95f7-0242ac130003-d2c7d714-f9ca-11ef-95f7-0242ac130003";
    const stormglassUrl = `https://api.stormglass.io/v2/weather/point?lat=${lat}&lng=${lon}&params=waterTemperature&source=noaa`;
    const stormglassTideUrl = `https://api.stormglass.io/v2/tide/extremes/point?lat=${lat}&lng=${lon}`;

    // Function to check if cache is valid (less than 6 hours old)
    function isCacheValid(cacheTime) {
      if (!cacheTime) return false;

      const cacheDate = new Date(cacheTime);
      const now = new Date();
      const hoursDiff = (now - cacheDate) / (1000 * 60 * 60); // Convert ms to hours

      return hoursDiff < 6; // Cache is valid for 6 hours
    }

    // Function to fetch water temperature with caching
    function fetchWaterTemperature() {
      // Vérifier que les éléments DOM existent
      if (!waterTempElement || !waterConditionsElement) {
        console.error("Les éléments DOM pour la température de l'eau n'existent pas");
        return;
      }

      // Check if we have cached data
      const cachedData = localStorage.getItem('sgWaterTempData');
      const cacheTime = localStorage.getItem('sgWaterTempTime');

      if (cachedData && isCacheValid(cacheTime)) {
        console.log("Using cached water temperature data");
        processWaterTempData(JSON.parse(cachedData));
        return;
      }

      // If no valid cache, make the API call
      console.log("Calling Stormglass API for water temperature");
      fetch(stormglassUrl, {
        headers: {
          'Authorization': `Bearer ${stormglassApiKey}` // Correction: ajout du préfixe 'Bearer '
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        console.log("Stormglass water temp data:", data);

        // Save to cache
        localStorage.setItem('sgWaterTempData', JSON.stringify(data));
        localStorage.setItem('sgWaterTempTime', new Date().toISOString());

        // Process the data
        processWaterTempData(data);
      })
      .catch(error => {
        console.error("Erreur lors de la récupération des données marines Stormglass:", error);
        // Check if we have old cached data we can use as fallback
        if (cachedData) {
          console.log("Using outdated cache as fallback");
          processWaterTempData(JSON.parse(cachedData));
        }
      });
    }

    // Function to process water temperature data
    function processWaterTempData(data) {
      // Check if we have water temperature data
      if (data.hours && data.hours.length > 0) {
        // Get the most recent water temperature reading
        const latestHour = data.hours[0];

        // Get the water temperature
        if (latestHour.waterTemperature && Object.keys(latestHour.waterTemperature).length > 0) {
          // Get the first available water temperature source
          const source = Object.keys(latestHour.waterTemperature)[0];
          const waterTemp = latestHour.waterTemperature[source];

          if (waterTemp) {
            // Update the water temperature display
            waterTempElement.textContent = `${Math.round(waterTemp)} °C`;

            // Set water conditions based on temperature
            if (waterTemp < 10) {
              waterConditionsElement.textContent = `Froide`;
            } else if (waterTemp < 18) {
              waterConditionsElement.textContent = `Fraîche`;
            } else if (waterTemp < 24) {
              waterConditionsElement.textContent = `Agréable`;
            } else {
              waterConditionsElement.textContent = `Chaude`;
            }
          }
        }
      }
    }

    // Function to fetch tide data with caching
    function fetchTideData() {
      // Check if we have cached data
      const cachedData = localStorage.getItem('sgTideData');
      const cacheTime = localStorage.getItem('sgTideTime');

      if (cachedData && isCacheValid(cacheTime)) {
        console.log("Using cached tide data");
        processTideData(JSON.parse(cachedData));
        return;
      }

      // If no valid cache, make the API call
      console.log("Calling Stormglass API for tide data");
      fetch(stormglassTideUrl, {
        headers: {
          'Authorization': `Bearer ${stormglassApiKey}` // Correction: ajout du préfixe 'Bearer '
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        console.log("Stormglass tide data:", data);

        // Save to cache
        localStorage.setItem('sgTideData', JSON.stringify(data));
        localStorage.setItem('sgTideTime', new Date().toISOString());

        // Process the data
        processTideData(data);
      })
      .catch(error => {
        console.error("Erreur lors de la récupération des données de marée Stormglass:", error);
        // Check if we have old cached data we can use as fallback
        if (cachedData) {
          console.log("Using outdated cache as fallback");
          processTideData(JSON.parse(cachedData));
        }
      });
    }

    // Function to process tide data
    function processTideData(data) {
      if (data.data && data.data.length >= 2) {
        // Get today's extremes
        const now = new Date();
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const todayEnd = new Date(todayStart);
        todayEnd.setDate(todayEnd.getDate() + 1);

        // Filter tide extremes for today
        const todayExtremes = data.data.filter(extreme => {
          const time = new Date(extreme.time);
          return time >= todayStart && time < todayEnd;
        });

        // Find the next high and low tides
        const highTides = todayExtremes.filter(extreme => extreme.type === 'high');
        const lowTides = todayExtremes.filter(extreme => extreme.type === 'low');

        // Get next high tide
        const tideHighElements = document.querySelectorAll(".tide-high .tide-time, .tide-high .tide-height");
        if (highTides.length > 0 && tideHighElements.length >= 2) {
          const nextHighTide = highTides[0];
          const highTideTime = new Date(nextHighTide.time);
          const formattedHighTime = `${highTideTime.getHours()}:${String(highTideTime.getMinutes()).padStart(2, '0')}`;
          const highTideHeight = Math.round(nextHighTide.height * 10) / 10; // Round to 1 decimal place

          tideHighElements[0].textContent = formattedHighTime;
          tideHighElements[1].textContent = `${highTideHeight} m`;
        }

        // Get next low tide
        const tideLowElements = document.querySelectorAll(".tide-low .tide-time, .tide-low .tide-height");
        if (lowTides.length > 0 && tideLowElements.length >= 2) {
          const nextLowTide = lowTides[0];
          const lowTideTime = new Date(nextLowTide.time);
          const formattedLowTime = `${lowTideTime.getHours()}:${String(lowTideTime.getMinutes()).padStart(2, '0')}`;
          const lowTideHeight = Math.round(nextLowTide.height * 10) / 10; // Round to 1 decimal place

          tideLowElements[0].textContent = formattedLowTime;
          tideLowElements[1].textContent = `${lowTideHeight} m`;
        }
      }
    }

    // Call the functions to fetch data
    fetchWaterTemperature();
    fetchTideData();
  });
</script>
