<!-- Slide 1 -->
<div class="slider">
  <div class="slide active">
    <div class="google-slides-container">
      <div class="slides-loader">
        <div class="loader">
          <div class="loader-inner"></div>
        </div>
      </div>
      <!-- Premier iframe pour le premier cycle -->
      <iframe
        id="google-slides-1"
        class="active-frame"
        src="https://docs.google.com/presentation/d/e/2PACX-1vSvfKn36DdHtN34zAKaEmG6-yrkPRF2Pks08fXsoTy5M-SqQlYZ2njpUVGuqr5_S1ZrcEg4ZHOS9s5v/embed?start=true&loop=true&delayms=15000&rm=minimal"
        frameborder="0"
        allowfullscreen="true"
        mozallowfullscreen="true"
        webkitallowfullscreen="true"
        onload="this.parentElement.classList.remove('loading')">
      </iframe>
      <!-- Deuxième iframe pour le cycle suivant -->
      <iframe
        id="google-slides-2"
        class="inactive-frame"
        src="about:blank"
        frameborder="0"
        allowfullscreen="true"
        mozallowfullscreen="true"
        webkitallowfullscreen="true"
        onload="this.parentElement.classList.remove('loading')">
      </iframe>
    </div>
  </div>

  <!-- Slide 2 - Météo -->
  <div class="slide ">
    <div class="background-image" style="background-image: url('https://res.cloudinary.com/dafkgjhwt/image/upload/v1741704836/chuttersnap-olqdyg9Bxg4-unsplash_qepzjz.jpg');"></div>
    <div class="header transparent">
      <h1>POINT MÉTÉO</h1>
      <h2>Quel temps fait-il ?</h2>
    </div>
    <div class="content weather">
      <div id="weather-container">
        <div class="loader">
          <div class="loader-inner"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Slide 3 - Conditions Nautiques -->
  <div class="slide">
  <div class="background-image" style="background-image: url('https://res.cloudinary.com/dafkgjhwt/image/upload/v1741704836/chuttersnap-olqdyg9Bxg4-unsplash_qepzjz.jpg');"></div>
    <div class="header transparent">
      <h1>POINT NAUTIQUE</h1>
      <h2>Quelles sont les conditions ?</h2>
    </div>
    <div class="content weather-conditions">
      <div id="marine-container">
        <div class="marine-data-grid">
          <!-- Wind Speed Panel -->
          <div class="marine-panel wind-panel">
            <h2>Vent</h2>
            <div class="wind-icon">
              <i class="wind-arrow"></i>
            </div>
            <p class="wind-speed">-- kts</p>
            <p class="wind-direction">Direction: --</p>
          </div>

          <!-- Water Temperature Panel -->
          <div class="marine-panel water-panel">
            <h2>Température Eau mer</h2>
            <p class="water-temp">-- °C</p>
            <p class="water-conditions">--</p>
          </div>

          <!-- Wind Forecast Chart -->
          <div class="marine-panel chart-panel">
            <h2>Prévision Vent 24h</h2>
            <canvas id="windChart"></canvas>
          </div>

          <!-- Sun Panel -->
          <div class="marine-panel sun-panel">
            <h2>Soleil</h2>
            <div class="sun-info">
              <div class="sunrise">
                <p>Lever</p>
                <div class="sun-icon">
                  <svg viewBox="0 0 24 24" width="48" height="48">
                    <path fill="#C6965B" d="M12,7L12,9M12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15M12,3L7.8,7.2M16.2,7.2L12,3M21,12L19,12M5,12L3,12M7.8,16.8L12,21L16.2,16.8M12,21L12,19M19,12A7,7 0 0,0 12,5A7,7 0 0,0 5,12"/>
                  </svg>
                </div>
                <p class="sun-time">--:--</p>
              </div>
              <div class="sunset">
                <p>Coucher</p>
                <div class="sun-icon">
                  <svg viewBox="0 0 24 24" width="48" height="48">
                    <path fill="#C6965B" d="M3,12H7A5,5 0 0,1 12,7A5,5 0 0,1 17,12H21A1,1 0 0,1 22,13A1,1 0 0,1 21,14H3A1,1 0 0,1 2,13A1,1 0 0,1 3,12M15,12A3,3 0 0,0 12,9A3,3 0 0,0 9,12H15M12,2L14.39,5.42C13.65,5.15 12.84,5 12,5C11.16,5 10.35,5.15 9.61,5.42L12,2M3.34,7L7.5,6.65C6.9,7.16 6.36,7.78 5.94,8.5C5.5,9.24 5.25,10 5.11,10.79L3.34,7M20.65,7L18.88,10.79C18.74,10 18.47,9.23 18.05,8.5C17.63,7.78 17.1,7.15 16.5,6.64L20.65,7M12.71,16.3L15.82,19.41C16.21,19.8 16.21,20.43 15.82,20.82C15.43,21.21 14.8,21.21 14.41,20.82L12,18.41L9.59,20.82C9.2,21.21 8.57,21.21 8.18,20.82C7.79,20.43 7.79,19.8 8.18,19.41L11.29,16.3C11.68,15.91 12.31,15.91 12.71,16.3Z"/>
                  </svg>
                </div>
                <p class="sun-time">--:--</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    const slides = document.querySelectorAll('.slider .slide');
    let currentSlideIndex = 0;
    const regularSlideDuration = 15000; // 15 secondes
    const googleSlidesDuration = 120000; // 8 slides * 15 secondes
    let slideInterval;
    let currentFrame = 1;
    const googleSlidesUrl = "https://docs.google.com/presentation/d/e/2PACX-1vSvfKn36DdHtN34zAKaEmG6-yrkPRF2Pks08fXsoTy5M-SqQlYZ2njpUVGuqr5_S1ZrcEg4ZHOS9s5v/embed?start=true&loop=true&delayms=15000&rm=minimal";

    // Constantes pour les API et la configuration
    const OPENWEATHER_API_KEY = "9556a80b8f760d847e244de8b062a80f";
    const STORMGLASS_API_KEY = "d2c7d6b0-f9ca-11ef-95f7-0242ac130003-d2c7d714-f9ca-11ef-95f7-0242ac130003";
    const LAT = 43.5;
    const LON = 4.9;
    const OPENWEATHER_API_URL = `https://api.openweathermap.org/data/3.0/onecall?lat=${LAT}&lon=${LON}&appid=${OPENWEATHER_API_KEY}&units=metric&lang=fr`;
    const STORMGLASS_URL = `https://api.stormglass.io/v2/weather/point?lat=${LAT}&lng=${LON}&params=waterTemperature&source=noaa`;

    // Constantes pour les heures de mise à jour
    const UPDATE_HOURS = [6, 12]; // Mise à jour à 6h et 12h
    const CACHE_DURATION_HOURS = 6; // Durée de validité du cache en heures

    // Constantes pour le stockage en cache
    const CACHE_KEYS = {
      WEATHER: 'weatherData',
      WEATHER_TIME: 'weatherTime',
      WATER_TEMP: 'sgWaterTempData',
      WATER_TEMP_TIME: 'sgWaterTempTime',
      TIDE: 'sgTideData',
      TIDE_TIME: 'sgTideTime'
    };

    function switchGoogleSlides() {
      const activeFrame = document.getElementById(`google-slides-${currentFrame}`);
      const nextFrame = document.getElementById(`google-slides-${currentFrame === 1 ? 2 : 1}`);
      const container = activeFrame.parentElement;

      // Activer le loader
      container.classList.add('loading');

      // Préparer le prochain frame
      nextFrame.src = googleSlidesUrl;

      // Basculer les classes
      activeFrame.classList.remove('active-frame');
      activeFrame.classList.add('inactive-frame');
      nextFrame.classList.remove('inactive-frame');
      nextFrame.classList.add('active-frame');

      // Mettre à jour le frame courant
      currentFrame = currentFrame === 1 ? 2 : 1;

      // Nettoyer l'ancien frame après la transition
      setTimeout(() => {
        activeFrame.src = 'about:blank';
      }, 1000);
    }

    function showNextSlide() {
      slides[currentSlideIndex].classList.remove('active');
      currentSlideIndex = (currentSlideIndex + 1) % slides.length;
      slides[currentSlideIndex].classList.add('active');

      if (currentSlideIndex === 0) {
        // Revenir au diaporama Google
        clearInterval(slideInterval);
        switchGoogleSlides();
        setTimeout(startRegularCycle, googleSlidesDuration);
      }
    }

    function startRegularCycle() {
      showNextSlide(); // Passer à la météo
      slideInterval = setInterval(showNextSlide, regularSlideDuration);
    }

    // --- SYSTÈME DE CACHE ET DE MISE À JOUR À HEURES FIXES ---

    // Fonction pour recharger la page aux heures de mise à jour
    function schedulePageRefresh() {
      const now = new Date();
      let nextUpdateTime;

      // Trouver la prochaine heure de mise à jour
      let foundNextHour = false;

      for (const hour of UPDATE_HOURS) {
        if (hour > now.getHours()) {
          nextUpdateTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, 0, 0);
          foundNextHour = true;
          break;
        }
      }

      // Si aucune heure restante aujourd'hui, planifier pour demain
      if (!foundNextHour && UPDATE_HOURS.length > 0) {
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        nextUpdateTime = new Date(tomorrow.getFullYear(), tomorrow.getMonth(), tomorrow.getDate(), UPDATE_HOURS[0], 0, 0);
      }

      // Calculer le délai avant le prochain rechargement
      const delay = nextUpdateTime - now;

      console.log(`Prochain rechargement de page programmé à ${nextUpdateTime.toLocaleTimeString()}`);
      setTimeout(() => {
        console.log("Rechargement de la page pour mise à jour météo...");
        location.reload();
      }, delay);
    }

    // --- METEO (One Call API 3.0) ---
    function fetchWeatherData() {
      const weatherContainer = document.getElementById("weather-container");

      // Ajouter la classe loading au début
      weatherContainer.classList.add('loading');

      fetch(OPENWEATHER_API_URL)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          console.log("Données météo reçues :", data);

          // Sauvegarder dans le cache
          localStorage.setItem(CACHE_KEYS.WEATHER, JSON.stringify(data));
          localStorage.setItem(CACHE_KEYS.WEATHER_TIME, new Date().toISOString());

          processWeatherData(data);
        })
        .catch(error => {
          console.error("Erreur lors de la récupération de la météo :", error);

          // Essayer d'utiliser les données en cache comme solution de secours
          const cachedData = localStorage.getItem(CACHE_KEYS.WEATHER);
          if (cachedData) {
            console.log("Utilisation des données en cache comme solution de secours");
            processWeatherData(JSON.parse(cachedData));
          } else {
            weatherContainer.classList.remove('loading');
            weatherContainer.innerHTML = "<p class='error-message'>Impossible de récupérer la météo pour le moment.</p>";
          }
        });
    }

    function processWeatherData(data) {
      const weatherContainer = document.getElementById("weather-container");

      if (!data.daily || data.daily.length < 4) {
        throw new Error("Données météo incomplètes");
      }

      // Générer le HTML pour l'affichage des 4 jours (aujourd'hui + 3 jours)
      let forecastHtml = `
        <div class="forecast-container">
      `;

      data.daily.slice(0, 4).forEach((day, index) => {
        const date = new Date(day.dt * 1000);
        const dayName = date.toLocaleDateString("fr-FR", { weekday: "long" });
        const temperature = Math.round(day.temp.day);
        const description = day.weather[0].description;
        const iconCode = day.weather[0].icon;
        // Utiliser l'image de meilleure qualité (4x au lieu de 2x)
        const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@4x.png`;
        const dayLabel = index === 0 ? "Aujourd'hui" : dayName.charAt(0).toUpperCase() + dayName.slice(1);

        forecastHtml += `
          <div class="daily-forecast">
            <h2>${dayLabel}</h2>
            <div class="weather-icon">
              <img src="${iconUrl}" alt="${description}">
            </div>
            <p class="temperature">${temperature} °C</p>
            <p class="description">${description}</p>
          </div>
        `;
      });

      forecastHtml += `</div>`;

      // Retirer la classe loading et injecter le contenu
      weatherContainer.classList.remove('loading');
      weatherContainer.innerHTML = forecastHtml;

      // Ajout du traitement des données solaires
      updateSunriseSunset(data);

      // Mise à jour des conditions marines
      updateMarineConditions(data);
    }

    function updateSunriseSunset(data) {
      if (data.current) {
        const sunrise = new Date(data.current.sunrise * 1000);
        const sunset = new Date(data.current.sunset * 1000);

        // Formatage des heures
        const formatTime = (date) => {
          return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        };

        // Mise à jour des éléments
        const sunriseElement = document.querySelector('.sunrise .sun-time');
        const sunsetElement = document.querySelector('.sunset .sun-time');

        if (sunriseElement && sunsetElement) {
          sunriseElement.textContent = formatTime(sunrise);
          sunsetElement.textContent = formatTime(sunset);
        }
      }
    }

    function updateMarineConditions(data) {
      const windSpeedElement = document.querySelector(".wind-speed");
      const windDirectionElement = document.querySelector(".wind-direction");

      if (windSpeedElement && windDirectionElement && data.current) {
        const windSpeed = Math.round(data.current.wind_speed * 1.94); // Convert m/s to knots
        const windDeg = data.current.wind_deg;

        // Update wind elements
        windSpeedElement.textContent = `${windSpeed} kts`;

        // Convert degrees to cardinal direction
        const directions = ["Nord", "Nord-Est", "Est", "Sud-Est", "Sud", "Sud-Ouest", "Ouest", "Nord-Ouest"];
        const index = Math.round(((windDeg + 22.5) % 360) / 45);
        windDirectionElement.textContent = `Direction: ${directions[index % 8]}`;

        // Rotate wind arrow according to direction
        const windArrow = document.querySelector(".wind-arrow");
        if (windArrow) {
          windArrow.style.transform = `rotate(${windDeg}deg)`;
        }
      }

      // Update wind chart
      updateWindForecastChart(data);
    }

    function updateWindForecastChart(data) {
      // Get hourly forecast for chart
      if (data.hourly && data.hourly.length >= 24) {
        const hourlyData = data.hourly.slice(0, 24);
        const times = hourlyData.map(hour => {
          const date = new Date(hour.dt * 1000);
          return date.getHours() + 'h';
        });

        const windSpeeds = hourlyData.map(hour => Math.round(hour.wind_speed * 1.94 * 10) / 10); // Précision à 0.1 près

        const ctx = document.getElementById('windChart').getContext('2d');

        // Détruire le graphique précédent s'il existe
        if (window.windChart instanceof Chart) {
          window.windChart.destroy();
        }

        window.windChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: times,
            datasets: [{
              label: 'Vitesse du vent (kts)',
              data: windSpeeds,
              fill: false,
              backgroundColor: '#C6965B',
              borderColor: '#C6965B',
              tension: 0.4,
              pointRadius: 3,
              pointBackgroundColor: '#C6965B'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: {
                left: 10,
                right: 10,
                top: 10,
                bottom: 10
              }
            },
            scales: {
              y: {
                beginAtZero: false, // Ne commence pas à zéro pour plus de précision
                grid: {
                  color: 'rgba(0, 0, 0, 0.1)',
                },
                ticks: {
                  stepSize: 2, // Incréments de 2 kts
                  font: {
                    size: 14
                  },
                  callback: function(value) {
                    return value + ' kts';
                  }
                },
                afterDataLimits: (scale) => {
                  // Ajuste les limites pour avoir une marge de 2 kts au-dessus et en-dessous
                  const minValue = Math.floor(Math.min(...windSpeeds) - 2);
                  const maxValue = Math.ceil(Math.max(...windSpeeds) + 2);
                  scale.min = Math.max(0, minValue); // Ne descend pas en dessous de 0
                  scale.max = maxValue;
                }
              },
              x: {
                grid: {
                  display: false
                },
                ticks: {
                  font: {
                    size: 14
                  },
                  maxRotation: 0,
                  maxTicksLimit: 8 // Limite le nombre d'heures affichées pour plus de clarté
                }
              }
            },
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return context.parsed.y.toFixed(1) + ' kts'; // Affiche une décimale dans le tooltip
                  }
                }
              }
            }
          }
        });
      }
    }

    // Function to fetch water temperature with caching
    function fetchWaterTemperature() {
      const waterTempElement = document.querySelector(".water-temp");
      const waterConditionsElement = document.querySelector(".water-conditions");

      if (!waterTempElement || !waterConditionsElement) {
        console.error("Éléments HTML pour la température de l'eau non trouvés");
        return;
      }

      // Si le cache existe et est récent (moins de 6 heures), l'utiliser
      const waterTempCacheTime = localStorage.getItem(CACHE_KEYS.WATER_TEMP_TIME);
      const cachedData = localStorage.getItem(CACHE_KEYS.WATER_TEMP);

      if (waterTempCacheTime && cachedData) {
        const cacheDate = new Date(waterTempCacheTime);
        const now = new Date();
        const hoursDiff = (now - cacheDate) / (1000 * 60 * 60);

        if (hoursDiff < CACHE_DURATION_HOURS) {
          console.log("Utilisation des données en cache pour la température de l'eau");
          processWaterTempData(JSON.parse(cachedData));
          return;
        }
      }

      console.log("Appel à l'API Stormglass pour la température de l'eau");
      fetch(STORMGLASS_URL, {
        headers: {
          'Authorization': STORMGLASS_API_KEY
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        console.log("Données de température d'eau Stormglass reçues:", data);

        // Sauvegarder dans le cache
        localStorage.setItem(CACHE_KEYS.WATER_TEMP, JSON.stringify(data));
        localStorage.setItem(CACHE_KEYS.WATER_TEMP_TIME, new Date().toISOString());

        // Traiter les données
        processWaterTempData(data);
      })
      .catch(error => {
        console.error("Erreur lors de la récupération des données marines Stormglass:", error);
        // Vérifier si nous avons des données en cache que nous pouvons utiliser
        const cachedData = localStorage.getItem(CACHE_KEYS.WATER_TEMP);
        if (cachedData) {
          console.log("Utilisation du cache comme solution de secours");
          processWaterTempData(JSON.parse(cachedData));
        }
      });
    }

    // Function to process water temperature data
    function processWaterTempData(data) {
      const waterTempElement = document.querySelector(".water-temp");
      const waterConditionsElement = document.querySelector(".water-conditions");

      if (!waterTempElement || !waterConditionsElement) {
        console.error("Éléments HTML pour la température de l'eau non trouvés");
        return;
      }

      // Check if we have water temperature data
      if (data.hours && data.hours.length > 0) {
        // Get the most recent water temperature reading
        const latestHour = data.hours[0];

        // Get the water temperature
        if (latestHour.waterTemperature && Object.keys(latestHour.waterTemperature).length > 0) {
          // Get the first available water temperature source
          const source = Object.keys(latestHour.waterTemperature)[0];
          const waterTemp = latestHour.waterTemperature[source];

          if (waterTemp) {
            // Update the water temperature display
            waterTempElement.textContent = `${Math.round(waterTemp)} °C`;

            // Set water conditions based on temperature
            if (waterTemp < 10) {
              waterConditionsElement.textContent = `Froide`;
            } else if (waterTemp < 18) {
              waterConditionsElement.textContent = `Fraîche`;
            } else if (waterTemp < 24) {
              waterConditionsElement.textContent = `Agréable`;
            } else {
              waterConditionsElement.textContent = `Chaude`;
            }
          }
        }
      }
    }

    // Démarrer le cycle de diapositives
    setTimeout(startRegularCycle, googleSlidesDuration);

    // Lire les données depuis le cache au chargement initial
    const weatherData = localStorage.getItem(CACHE_KEYS.WEATHER);
    if (weatherData) {
      console.log("Chargement des données météo depuis le cache");
      processWeatherData(JSON.parse(weatherData));
    } else {
      // Première exécution, récupérer les données
      fetchWeatherData();
    }

    // Charger les données marines depuis le cache ou les récupérer
    fetchWaterTemperature();

    // Programme un rechargement de page aux heures spécifiées
    // au lieu d'utiliser une boucle de vérification continuelle
    schedulePageRefresh();
  });
</script>
