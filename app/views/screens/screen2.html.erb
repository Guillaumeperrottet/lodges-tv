<!-- Slide 1 -->
<div class="slider">
  <div class="slide active">
    <div class="google-slides-container">
      <div class="slides-loader">
        <div class="loader">
          <div class="loader-inner"></div>
        </div>
      </div>
      <!-- Premier iframe pour le premier cycle -->
      <iframe
        id="google-slides-1"
        class="active-frame"
        src="https://docs.google.com/presentation/d/e/2PACX-1vSvfKn36DdHtN34zAKaEmG6-yrkPRF2Pks08fXsoTy5M-SqQlYZ2njpUVGuqr5_S1ZrcEg4ZHOS9s5v/embed?start=true&loop=true&delayms=15000&rm=minimal"
        frameborder="0"
        allowfullscreen="true"
        mozallowfullscreen="true"
        webkitallowfullscreen="true"
        onload="this.parentElement.classList.remove('loading')">
      </iframe>
      <!-- Deuxième iframe pour le cycle suivant -->
      <iframe
        id="google-slides-2"
        class="inactive-frame"
        src="about:blank"
        frameborder="0"
        allowfullscreen="true"
        mozallowfullscreen="true"
        webkitallowfullscreen="true"
        onload="this.parentElement.classList.remove('loading')">
      </iframe>
    </div>
  </div>

  <!-- Slide 2 - Météo -->
  <div class="slide ">
    <div class="background-image" style="background-image: url('https://res.cloudinary.com/dafkgjhwt/image/upload/v1741704836/chuttersnap-olqdyg9Bxg4-unsplash_qepzjz.jpg');"></div>
    <div class="header transparent">
      <h1>POINT MÉTÉO</h1>
      <h2>Quel temps fait-il ?</h2>
    </div>
    <div class="content weather">
      <div id="weather-container">
        <div class="loader">
          <div class="loader-inner"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Slide 3 - Conditions Nautiques -->
  <div class="slide">
  <div class="background-image" style="background-image: url('https://res.cloudinary.com/dafkgjhwt/image/upload/v1741704836/chuttersnap-olqdyg9Bxg4-unsplash_qepzjz.jpg');"></div>
    <div class="header transparent">
      <h1>POINT NAUTIQUE</h1>
      <h2>Quelles sont les conditions ?</h2>
    </div>
    <div class="content weather-conditions">
      <div id="marine-container">
        <div class="marine-data-grid">
          <!-- Wind Speed Panel -->
          <div class="marine-panel wind-panel">
            <h2>Vent</h2>
            <div class="wind-icon">
              <i class="wind-arrow"></i>
            </div>
            <p class="wind-speed">-- kts</p>
            <p class="wind-direction">Direction: --</p>
          </div>

          <!-- Water Temperature Panel -->
          <div class="marine-panel water-panel">
            <h2>Température Eau mer</h2>
            <div class="temp-icon">
              <i class="water-icon"></i>
            </div>
            <p class="water-temp">-- °C</p>
            <p class="water-conditions">--</p>
          </div>

          <!-- Wind Forecast Chart -->
          <div class="marine-panel chart-panel">
            <h2>Prévision Vent 24h</h2>
            <canvas id="windChart"></canvas>
          </div>

          <!-- Sun Panel -->
          <div class="marine-panel sun-panel">
            <h2>Soleil</h2>
            <div class="sun-info">
              <div class="sunrise">
                <p>Lever</p>
                <div class="sun-icon">
                  <svg viewBox="0 0 24 24" width="48" height="48">
                    <path fill="#C6965B" d="M12,7L12,9M12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15M12,3L7.8,7.2M16.2,7.2L12,3M21,12L19,12M5,12L3,12M7.8,16.8L12,21L16.2,16.8M12,21L12,19M19,12A7,7 0 0,0 12,5A7,7 0 0,0 5,12"/>
                  </svg>
                </div>
                <p class="sun-time">--:--</p>
              </div>
              <div class="sunset">
                <p>Coucher</p>
                <div class="sun-icon">
                  <svg viewBox="0 0 24 24" width="48" height="48">
                    <path fill="#C6965B" d="M3,12H7A5,5 0 0,1 12,7A5,5 0 0,1 17,12H21A1,1 0 0,1 22,13A1,1 0 0,1 21,14H3A1,1 0 0,1 2,13A1,1 0 0,1 3,12M15,12A3,3 0 0,0 12,9A3,3 0 0,0 9,12H15M12,2L14.39,5.42C13.65,5.15 12.84,5 12,5C11.16,5 10.35,5.15 9.61,5.42L12,2M3.34,7L7.5,6.65C6.9,7.16 6.36,7.78 5.94,8.5C5.5,9.24 5.25,10 5.11,10.79L3.34,7M20.65,7L18.88,10.79C18.74,10 18.47,9.23 18.05,8.5C17.63,7.78 17.1,7.15 16.5,6.64L20.65,7M12.71,16.3L15.82,19.41C16.21,19.8 16.21,20.43 15.82,20.82C15.43,21.21 14.8,21.21 14.41,20.82L12,18.41L9.59,20.82C9.2,21.21 8.57,21.21 8.18,20.82C7.79,20.43 7.79,19.8 8.18,19.41L11.29,16.3C11.68,15.91 12.31,15.91 12.71,16.3Z"/>
                  </svg>
                </div>
                <p class="sun-time">--:--</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    const slides = document.querySelectorAll('.slider .slide');
    let currentSlideIndex = 0;
    const regularSlideDuration = 15000; // 15 secondes
    const googleSlidesDuration = 120000; // 8 slides * 15 secondes
    let slideInterval;
    let currentFrame = 1;
    const googleSlidesUrl = "https://docs.google.com/presentation/d/e/2PACX-1vSvfKn36DdHtN34zAKaEmG6-yrkPRF2Pks08fXsoTy5M-SqQlYZ2njpUVGuqr5_S1ZrcEg4ZHOS9s5v/embed?start=true&loop=true&delayms=15000&rm=minimal";

    function switchGoogleSlides() {
      const activeFrame = document.getElementById(`google-slides-${currentFrame}`);
      const nextFrame = document.getElementById(`google-slides-${currentFrame === 1 ? 2 : 1}`);
      const container = activeFrame.parentElement;

      // Activer le loader
      container.classList.add('loading');

      // Préparer le prochain frame
      nextFrame.src = googleSlidesUrl;

      // Basculer les classes
      activeFrame.classList.remove('active-frame');
      activeFrame.classList.add('inactive-frame');
      nextFrame.classList.remove('inactive-frame');
      nextFrame.classList.add('active-frame');

      // Mettre à jour le frame courant
      currentFrame = currentFrame === 1 ? 2 : 1;

      // Nettoyer l'ancien frame après la transition
      setTimeout(() => {
        activeFrame.src = 'about:blank';
      }, 1000);
    }

    function showNextSlide() {
      slides[currentSlideIndex].classList.remove('active');
      currentSlideIndex = (currentSlideIndex + 1) % slides.length;
      slides[currentSlideIndex].classList.add('active');

      if (currentSlideIndex === 0) {
        // Revenir au diaporama Google
        clearInterval(slideInterval);
        switchGoogleSlides();
        setTimeout(startRegularCycle, googleSlidesDuration);
      }
    }

    function startRegularCycle() {
      showNextSlide(); // Passer à la météo
      slideInterval = setInterval(showNextSlide, regularSlideDuration);
    }

    // Démarrer le premier cycle
    setTimeout(startRegularCycle, googleSlidesDuration);

    // --- COMMON VARIABLES ---
    const apiKey = "9556a80b8f760d847e244de8b062a80f";
    const lat = 43.5;
    const lon = 4.9;
    const apiUrl = `https://api.openweathermap.org/data/3.0/onecall?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=fr`;

    // --- METEO (One Call API 3.0) ---
    const weatherContainer = document.getElementById("weather-container");

    // Ajouter la classe loading au début
    weatherContainer.classList.add('loading');

    fetch(apiUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        console.log("Données marines reçues :", data);
        if (!data.daily || data.daily.length < 4) {
          throw new Error("Données météo incomplètes");
        }

        // Générer le HTML pour l'affichage des 4 jours (aujourd'hui + 3 jours)
        let forecastHtml = `
          <div class="forecast-container">
        `;

        data.daily.slice(0, 4).forEach((day, index) => {
          const date = new Date(day.dt * 1000);
          const dayName = date.toLocaleDateString("fr-FR", { weekday: "long" });
          const temperature = Math.round(day.temp.day);
          const description = day.weather[0].description;
          const iconCode = day.weather[0].icon;
          // Utiliser l'image de meilleure qualité (4x au lieu de 2x)
          const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@4x.png`;
          const dayLabel = index === 0 ? "Aujourd'hui" : dayName.charAt(0).toUpperCase() + dayName.slice(1);

          forecastHtml += `
            <div class="daily-forecast">
              <h2>${dayLabel}</h2>
              <div class="weather-icon">
                <img src="${iconUrl}" alt="${description}">
              </div>
              <p class="temperature">${temperature} °C</p>
              <p class="description">${description}</p>
            </div>
          `;
        });

        forecastHtml += `</div>`;

        // Retirer la classe loading et injecter le contenu
        weatherContainer.classList.remove('loading');
        weatherContainer.innerHTML = forecastHtml;

        // Ajout du traitement des données solaires
        if (data.current) {
          const sunrise = new Date(data.current.sunrise * 1000);
          const sunset = new Date(data.current.sunset * 1000);

          // Formatage des heures
          const formatTime = (date) => {
            return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
          };

          // Mise à jour des éléments
          const sunriseElement = document.querySelector('.sunrise .sun-time');
          const sunsetElement = document.querySelector('.sunset .sun-time');

          if (sunriseElement && sunsetElement) {
            sunriseElement.textContent = formatTime(sunrise);
            sunsetElement.textContent = formatTime(sunset);
          }
        }
      })
      .catch(error => {
        console.error("Erreur lors de la récupération de la météo :", error);
        weatherContainer.classList.remove('loading');
        weatherContainer.innerHTML = "<p class='error-message'>Impossible de récupérer la météo pour le moment.</p>";
      });

    // --- MARINE CONDITIONS ---
    const marineContainer = document.getElementById("marine-container");
    const windSpeedElement = document.querySelector(".wind-speed");
    const windDirectionElement = document.querySelector(".wind-direction");
    const waterTempElement = document.querySelector(".water-temp");
    const waterConditionsElement = document.querySelector(".water-conditions");

    console.log("windSpeedElement:", windSpeedElement);
    console.log("windDirectionElement:", windDirectionElement);

    // Using the same API call as weather, to avoid duplication
    fetch(apiUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        // Wind data from current conditions
        if (data.current) {
          const windSpeed = Math.round(data.current.wind_speed * 1.94); // Convert m/s to km/h
          const windDeg = data.current.wind_deg;

          // Update wind elements
          windSpeedElement.textContent = `${windSpeed} kts`;

          // Convert degrees to cardinal direction
          const directions = ["Nord", "Nord-Est", "Est", "Sud-Est", "Sud", "Sud-Ouest", "Ouest", "Nord-Ouest"];
          const index = Math.round(((windDeg + 22.5) % 360) / 45);
          windDirectionElement.textContent = `Direction: ${directions[index % 8]}`;

          // Rotate wind arrow according to direction
          const windArrow = document.querySelector(".wind-arrow");
          if (windArrow) {
            windArrow.style.transform = `rotate(${windDeg}deg)`;
          }
        }

          // Get hourly forecast for chart
          if (data.hourly && data.hourly.length >= 24) {
            const hourlyData = data.hourly.slice(0, 24);
            const times = hourlyData.map(hour => {
              const date = new Date(hour.dt * 1000);
              return date.getHours() + 'h';
            });

            const windSpeeds = hourlyData.map(hour => Math.round(hour.wind_speed * 1.94 * 10) / 10); // Précision à 0.1 près

            const ctx = document.getElementById('windChart').getContext('2d');
            const windChart = new Chart(ctx, {
              type: 'line',
              data: {
                labels: times,
                datasets: [{
                  label: 'Vitesse du vent (kts)',
                  data: windSpeeds,
                  fill: false,
                  backgroundColor: '#C6965B',
                  borderColor: '#C6965B',
                  tension: 0.4,
                  pointRadius: 3,
                  pointBackgroundColor: '#C6965B'
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                  padding: {
                    left: 10,
                    right: 10,
                    top: 10,
                    bottom: 10
                  }
                },
                scales: {
                  y: {
                    beginAtZero: false, // Ne commence pas à zéro pour plus de précision
                    grid: {
                      color: 'rgba(0, 0, 0, 0.1)',
                    },
                    ticks: {
                      stepSize: 2, // Incréments de 2 kts
                      font: {
                        size: 14
                      },
                      callback: function(value) {
                        return value + ' kts';
                      }
                    },
                    afterDataLimits: (scale) => {
                      // Ajuste les limites pour avoir une marge de 2 kts au-dessus et en-dessous
                      const minValue = Math.floor(Math.min(...windSpeeds) - 2);
                      const maxValue = Math.ceil(Math.max(...windSpeeds) + 2);
                      scale.min = Math.max(0, minValue); // Ne descend pas en dessous de 0
                      scale.max = maxValue;
                    }
                  },
                  x: {
                    grid: {
                      display: false
                    },
                    ticks: {
                      font: {
                        size: 14
                      },
                      maxRotation: 0,
                      maxTicksLimit: 8 // Limite le nombre d'heures affichées pour plus de clarté
                    }
                  }
                },
                plugins: {
                  legend: {
                    display: false
                  },
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        return context.parsed.y.toFixed(1) + ' kts'; // Affiche une décimale dans le tooltip
                      }
                    }
                  }
                }
              }
            });
          }
      })

      .catch(error => {
        console.error("Erreur lors de la récupération des données marines :", error);
        marineContainer.innerHTML = "<p class='error-message'>Impossible de récupérer les données marines pour le moment.</p>";
      });

        // --- STORMGLASS API WITH CACHING ---
        const stormglassApiKey = "d2c7d6b0-f9ca-11ef-95f7-0242ac130003-d2c7d714-f9ca-11ef-95f7-0242ac130003";
        const stormglassUrl = `https://api.stormglass.io/v2/weather/point?lat=${lat}&lng=${lon}&params=waterTemperature&source=noaa`;
        const stormglassTideUrl = `https://api.stormglass.io/v2/tide/extremes/point?lat=${lat}&lng=${lon}`;

        // Function to check if cache is valid (less than 6 hours old)
        function isCacheValid(cacheTime) {
          if (!cacheTime) return false;

          const cacheDate = new Date(cacheTime);
          const now = new Date();
          const hoursDiff = (now - cacheDate) / (1000 * 60 * 60); // Convert ms to hours

          return hoursDiff < 6; // Cache is valid for 6 hours
        }

        // Function to fetch water temperature with caching
        function fetchWaterTemperature() {
          // Check if we have cached data
          const cachedData = localStorage.getItem('sgWaterTempData');
          const cacheTime = localStorage.getItem('sgWaterTempTime');

          if (cachedData && isCacheValid(cacheTime)) {
            console.log("Using cached water temperature data");
            processWaterTempData(JSON.parse(cachedData));
            return;
          }

          // If no valid cache, make the API call
          console.log("Calling Stormglass API for water temperature");
          fetch(stormglassUrl, {
            headers: {
              'Authorization': stormglassApiKey
            }
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            console.log("Stormglass water temp data:", data);

            // Save to cache
            localStorage.setItem('sgWaterTempData', JSON.stringify(data));
            localStorage.setItem('sgWaterTempTime', new Date().toISOString());

            // Process the data
            processWaterTempData(data);
          })
          .catch(error => {
            console.error("Erreur lors de la récupération des données marines Stormglass:", error);
            // Check if we have old cached data we can use as fallback
            if (cachedData) {
              console.log("Using outdated cache as fallback");
              processWaterTempData(JSON.parse(cachedData));
            }
          });
        }

        // Function to process water temperature data
        function processWaterTempData(data) {
          // Check if we have water temperature data
          if (data.hours && data.hours.length > 0) {
            // Get the most recent water temperature reading
            const latestHour = data.hours[0];

            // Get the water temperature
            if (latestHour.waterTemperature && Object.keys(latestHour.waterTemperature).length > 0) {
              // Get the first available water temperature source
              const source = Object.keys(latestHour.waterTemperature)[0];
              const waterTemp = latestHour.waterTemperature[source];

              if (waterTemp) {
                // Update the water temperature display
                waterTempElement.textContent = `${Math.round(waterTemp)} °C`;

                // Set water conditions based on temperature
                if (waterTemp < 10) {
                  waterConditionsElement.textContent = `Froide`;
                } else if (waterTemp < 18) {
                  waterConditionsElement.textContent = `Fraîche`;
                } else if (waterTemp < 24) {
                  waterConditionsElement.textContent = `Agréable`;
                } else {
                  waterConditionsElement.textContent = `Chaude`;
                }
              }
            }
          }
        }

        // Function to fetch tide data with caching
        function fetchTideData() {
          // Check if we have cached data
          const cachedData = localStorage.getItem('sgTideData');
          const cacheTime = localStorage.getItem('sgTideTime');

          if (cachedData && isCacheValid(cacheTime)) {
            console.log("Using cached tide data");
            processTideData(JSON.parse(cachedData));
            return;
          }

          // If no valid cache, make the API call
          console.log("Calling Stormglass API for tide data");
          fetch(stormglassTideUrl, {
            headers: {
              'Authorization': stormglassApiKey
            }
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            console.log("Stormglass tide data:", data);

            // Save to cache
            localStorage.setItem('sgTideData', JSON.stringify(data));
            localStorage.setItem('sgTideTime', new Date().toISOString());

            // Process the data
            processTideData(data);
          })
          .catch(error => {
            console.error("Erreur lors de la récupération des données de marée Stormglass:", error);
            // Check if we have old cached data we can use as fallback
            if (cachedData) {
              console.log("Using outdated cache as fallback");
              processTideData(JSON.parse(cachedData));
            }
          });
        }

        // Function to process tide data
        function processTideData(data) {
          if (data.data && data.data.length >= 2) {
            // Get today's extremes
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayEnd = new Date(todayStart);
            todayEnd.setDate(todayEnd.getDate() + 1);

            // Filter tide extremes for today
            const todayExtremes = data.data.filter(extreme => {
              const time = new Date(extreme.time);
              return time >= todayStart && time < todayEnd;
            });

            // Find the next high and low tides
            const highTides = todayExtremes.filter(extreme => extreme.type === 'high');
            const lowTides = todayExtremes.filter(extreme => extreme.type === 'low');

            // Get next high tide
            const tideHighElements = document.querySelectorAll(".tide-high .tide-time, .tide-high .tide-height");
            if (highTides.length > 0 && tideHighElements.length >= 2) {
              const nextHighTide = highTides[0];
              const highTideTime = new Date(nextHighTide.time);
              const formattedHighTime = `${highTideTime.getHours()}:${String(highTideTime.getMinutes()).padStart(2, '0')}`;
              const highTideHeight = Math.round(nextHighTide.height * 10) / 10; // Round to 1 decimal place

              tideHighElements[0].textContent = formattedHighTime;
              tideHighElements[1].textContent = `${highTideHeight} m`;
            }

            // Get next low tide
            const tideLowElements = document.querySelectorAll(".tide-low .tide-time, .tide-low .tide-height");
            if (lowTides.length > 0 && tideLowElements.length >= 2) {
              const nextLowTide = lowTides[0];
              const lowTideTime = new Date(nextLowTide.time);
              const formattedLowTime = `${lowTideTime.getHours()}:${String(lowTideTime.getMinutes()).padStart(2, '0')}`;
              const lowTideHeight = Math.round(nextLowTide.height * 10) / 10; // Round to 1 decimal place

              tideLowElements[0].textContent = formattedLowTime;
              tideLowElements[1].textContent = `${lowTideHeight} m`;
            }
          }
        }

        // Call the functions to fetch data
        fetchWaterTemperature();
        fetchTideData();
  });
</script>
